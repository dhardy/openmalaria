/*
 This file is part of OpenMalaria.
 
 Copyright (C) 2005-2009 Swiss Tropical Institute and Liverpool School Of Tropical Medicine
 
 OpenMalaria is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or (at
 your option) any later version.
 
 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*/

#ifndef Hmod_VectorEmergenceSuite
#define Hmod_VectorEmergenceSuite

#include <fstream>
#include <string>
#include <sstream>
#include <stdexcept>
using namespace std;

#include <cxxtest/TestSuite.h>

#include "Transmission/VectorEmergence.h"
#include "Transmission/VectorSpecies.h"

// We want to hide normal output, so route it here instead of cout
ofstream null("\0");

// This is the smallest power of ten sufficient to pass current tests; so it
// may need to be increased.
const double MY_DELTA = 0.0000001;

/** Tests on the Vector Control Emergence Rate calculation code.
 *
 * The output values were generated by NC using Matlab versions of these
 * functions. */
class VectorEmergenceSuite : public CxxTest::TestSuite
{
public:
  VectorEmergenceSuite () :
      emerge(3, 5, POP_SIZE, AVG_AVAIL, 1.6, 0.33, .95, .95, .94, .93,
	     YEAR_LEN, null, "\0")
  {
    ifstream file ("VectorEmergenceSuite.txt");
    if (!file.good()) throw runtime_error ("Unable to read VectorEmergenceSuite.txt");
    input1CalcInv1minusA = readMatrix(file, "input1CalcInv1minusA",17);
    output1CalcInv1minusA = readMatrix(file, "output1CalcInv1minusA",17);
    input1CalcSpectralRadius = readMatrix(file,"input1CalcSpectralRadius",17);
  }
  ~VectorEmergenceSuite () {
    gsl_matrix_free (input1CalcInv1minusA);
    gsl_matrix_free (output1CalcInv1minusA);
    gsl_matrix_free (input1CalcSpectralRadius);
  }
  
  void testCalcPSTS () {
    // Also considered inputs: tau=3, theta_s=5
    double sumKPlus;
    double sumKLPlus[2];
    emerge.CalcPSTS (&sumKPlus, sumKLPlus, 5.4803567e-002, 6.1014058e-001);
    TS_ASSERT_DELTA (sumKPlus, 3.0034309e-003, MY_DELTA);
    TS_ASSERT_DELTA (sumKLPlus[0], 6.1014058e-001, MY_DELTA);
    TS_ASSERT_DELTA (sumKLPlus[1], 3.3437880e-002, MY_DELTA);
  }
  
  void testCalcSpectralRadius () {
    TS_ASSERT_DELTA (emerge.CalcSpectralRadius (input1CalcSpectralRadius), 2.3950405e-001, MY_DELTA);
  }
  
  void testCalcInv1minusA () {
    // Considered an input: eta = 17
    gsl_matrix* inv1A = gsl_matrix_calloc(17,17);
    emerge.CalcInv1minusA (inv1A, input1CalcInv1minusA);
    checkEqual (inv1A, output1CalcInv1minusA, "output1CalcInv1minusA");
    
    gsl_matrix_free (inv1A);
  }
  
  void testWholeCalculation () {
    Global::clOptions = static_cast<CLO::CLO> (Global::clOptions | CLO::ENABLE_ERC);
    
    vector<double> humanInfectivityInit(YEAR_LEN, 0.0);	//TODO: init
    vector<double> EIRInit(YEAR_LEN, 0.0);
    // Fourier cooeficients for EIR array
    vector<double> fc (5,0.0);
    fc[0] = -0.926517;	// a0
    fc[1] = -0.692164;	fc[2] =  0.002098;	// a1,b1
    fc[3] =  0.401189;	fc[4] = -0.375356;	// a2,b2
    VectorTransmissionSpecies::calcInverseDFTExp (EIRInit, fc);
    
    double emergenceRate[YEAR_LEN];
    const double temp = POP_SIZE*POP_SIZE*AVG_AVAIL;
    for (int i = 0; i < YEAR_LEN; i++) {
      emergenceRate[i] = EIRInit[i]*temp;
    }
    
    emerge.CalcInitMosqEmergeRate(1,1,	//NOTE: no support for these not-being 1 yet
				  &humanInfectivityInit[0],
				  EIRInit,
				  emergenceRate);
    TS_WARN ("TODO: test output");
  }
  
private:
  void checkNextString (istream& in, string expect) {
    string name;
    in >> name;
    if (expect != name) {
      ostringstream msg;
      msg << "Next item expected in VectorEmergenceSuite.txt: "
      << expect
      << ", got: "
      << name;
      throw runtime_error (msg.str());
    }
  }
  gsl_matrix* readMatrix (istream& in, string name, int dim) {
    checkNextString (in, name);
    gsl_matrix* ret = gsl_matrix_calloc (dim, dim);
    double x;
    for (int i = 0; i < dim; ++i)
      for (int j = 0; j < dim; ++j) {
	in >> x;
	gsl_matrix_set(ret,i,j, x);
      }
    return ret;
  }
  void checkEqual (gsl_matrix* A, gsl_matrix* B, const char* msg) {
    for (int i = 0; i < emerge.eta; ++i)
      for (int j = 0; j < emerge.eta; ++j)
	TSM_ASSERT_DELTA (msg, gsl_matrix_get(A,i,j), gsl_matrix_get(B,i,j), MY_DELTA);
  }
  
  // Number of "days" in our "year" (to speed up tests)
  static const int YEAR_LEN = 10;
  // Population size
  static const int POP_SIZE = 1000;
  // Average availability
  static const double AVG_AVAIL = 0.0072;
  
  VectorEmergence emerge;
  
  gsl_matrix *input1CalcInv1minusA, *output1CalcInv1minusA;
  gsl_matrix *input1CalcSpectralRadius;
};

#endif
